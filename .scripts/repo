#!/opt/homebrew/bin/bash
# vim: set filetype=sh:

GREEN='\033[0;32m'
BLUE='\033[0;34m'
RED='\033[0;31m'
ORANGE='\033[0;33m'
NC='\033[0m' # No Color

repos_path="$HOME/Documents/dev/repos"

print_positive() {
    printf "${GREEN}::: Repo - %s${NC}\n" "$1"
}

print_info() {
    printf "${BLUE}::: Repo - %s${NC}\n" "$1"
}

print_negative() {
    printf "${RED}::: Repo - %s${NC}\n" "$1"
}

clone_repo() {
    local gitUrl=$1
    local basePath="/Users/nikolausbrunner/Documents/dev/repos"

    local repoDetails
    local username
    local repoName

    repoDetails=$(echo "$gitUrl" | awk -F '[/:]' '{print $(NF-1)"/"$NF}' | sed 's/.git$//')
    username=$(echo "$repoDetails" | cut -d '/' -f 1)
    repoName=$(echo "$repoDetails" | cut -d '/' -f 2)

    local fullPath="$basePath/${username}@${repoName}"

    print_positive "Cloning $gitUrl to $fullPath..."

    git clone "$gitUrl" "$fullPath"
}

remove_repo() {
    selected_repo=$(select_repo)

    if [ -n "$selected_repo" ]; then
        print_negative "Removing $selected_repo..."
        rm -rf "$selected_repo"
    else
        print_info "No repository selected."
    fi
}

select_repo() {
    local IFS=$'\n' dirs names selected_name full_path
    # Use mapfile to read the full directory paths into an array
    mapfile -t dirs < <(find "$repos_path" -maxdepth 1 -type d -not -path "$repos_path" | sort)

    # Use mapfile to read the directory names into an array, converting full paths to basenames
    mapfile -t names < <(printf '%s\n' "${dirs[@]}" | xargs -I {} basename {} | sort)

    # Let the user select a directory name
    selected_name=$(printf '%s\n' "${names[@]}" | fzf --prompt='Select a repository: ')

    # Find the full path of the selected directory
    for dir in "${dirs[@]}"; do
        if [[ $(basename "$dir") == "$selected_name" ]]; then
            full_path="$dir"
            break
        fi
    done

    # Return the full path
    echo "$full_path"
}

open_repo() {
    # If open_repo was called with an argument, use that as the selected repo
    local selected_repo
    if [ -n "$1" ]; then
        selected_repo="$1"
    else
        selected_repo=$(select_repo)
    fi

    echo "Test: repo [[selected_repo]]: $selected_repo"

    # If a repo was selected
    if [ -n "$selected_repo" ]; then
        # TODO: Check if tmux session already exists
        # If it does, switch to it instead of creating a new one and notify the user about it
        # Else proceed with creating a new session

        # Parse the selected_repo string to get string after @
        session_name=$(echo "$selected_repo" | cut -d'@' -f2 | tr '.' '_')

        # Start a new tmux session with the selected repo as the cwd
        tmux new-session -d -s "$session_name" -c "$selected_repo"

        # Rename the first window "code"
        tmux rename-window -t "$session_name":1 "code"

        # Run "nvim ." in the first window
        tmux send-keys -t "$session_name":1 "nvim ." Enter

        # Create a new window with the same cwd
        tmux new-window -t "$session_name" -c "$selected_repo" -n "run"

        # Run "tmux_2x2_layout" in the second window
        tmux send-keys -t "$session_name":2 "tmux_2x2_layout" Enter

        # Display loading message in the status bar
        print_positive "Opening $selected_repo..."

        sleep 2

        # Switch to the new session
        tmux switch-client -t "$session_name"

        # Select the first window "code"
        tmux select-window -t "$session_name":1
    else
        print_info "No repository selected."
    fi
}

get_status() {
    local number_of_repos_with_unstaged_changes=0
    local -a repos_with_changes=()

    for dir in "$repos_path"/*; do
        if [[ -d "$dir" && ! -L "$dir" ]]; then # Check if it's a directory and not a symlink
            local repo_name
            repo_name=$(basename "$dir")
            # Check if the directory is a Git repository
            if git -C "$dir" rev-parse >/dev/null 2>&1; then
                # Check if there are any commits
                if git -C "$dir" rev-parse HEAD >/dev/null 2>&1; then
                    # Get the last commit's author, message, and date
                    local last_author
                    local last_message
                    local last_date
                    last_author=$(git -C "$dir" log -1 --pretty=format:"%an" 2>/dev/null)
                    last_message=$(git -C "$dir" log -1 --pretty=format:"%s" 2>/dev/null)
                    last_date=$(git -C "$dir" log -1 --pretty=format:"%cd" 2>/dev/null)

                    local repo_status_color=$GREEN
                    local status_msg=""
                    # Check for uncommitted changes
                    if ! git -C "$dir" diff --quiet; then
                        number_of_repos_with_unstaged_changes=$((number_of_repos_with_unstaged_changes + 1))
                        repo_status_color=$RED
                        status_msg=" (Uncommitted changes)"
                        repos_with_changes+=("$(basename "$dir")") # Add to the list of repos with changes
                    fi

                    # Replace the @ in the repo name with a / to make it recognizable as a clickable href github link
                    local display_repo_name
                    display_repo_name=$(echo "$repo_name" | tr '@' '/')

                    # Print the repo name out in red or green depending on the status
                    printf "${repo_status_color}%s${NC}%s\n" "$display_repo_name" "$status_msg"
                    # Print the commit details with color for each part
                    printf "  ${ORANGE}%s${NC} ${GREEN}%s${NC} ${BLUE}%s${NC}\n" "$last_author" "$last_message" "$last_date"
                else
                    # Repo exists but no commits have been made yet
                    printf "${ORANGE}%s\n  No commits yet\n" "$repo_name"
                fi
            else
                printf "${NC}%s\n  Not a git repository\n" "$repo_name"
            fi
        fi
    done

    echo ""
    echo ":::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::"
    print_info "Number of repositories: $(find "$repos_path" -maxdepth 1 -type d -not -path "$repos_path" | wc -l)"

    # If there are repos with uncommitted changes, ask the user if they want to open one
    if ((number_of_repos_with_unstaged_changes > 0)); then
        print_negative "You have $number_of_repos_with_unstaged_changes repositories with uncommitted changes."
        read -p "Do you want to open one of them? (y/N) " -n 1 -r
        echo # move to a new line

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # Use fzf to let the user select one of the repos with uncommitted changes
            local selected_repo
            selected_repo=$(printf '%s\n' "${repos_with_changes[@]}" | fzf --prompt='Select a repository to open: ')

            # Get the full path of the selected repo
            for dir in "$repos_path"/*; do
                if [[ -d "$dir" && ! -L "$dir" ]]; then # Check if it's a directory and not a symlink
                    local repo_name
                    repo_name=$(basename "$dir")
                    if [[ "$repo_name" == "$selected_repo" ]]; then
                        selected_repo="$dir"
                        break
                    fi
                fi
            done

            # Check if the user made a selection
            if [ -n "$selected_repo" ]; then
                open_repo "$selected_repo"
            else
                print_info "No repository selected."
            fi
        # If the user pressed N or n, ask him if he wants open up one the other repos by calling open_repo without an argument
        elif [[ ! $REPLY =~ ^[Yy]$ ]]; then
            read -p "Do you want to open one of the other repositories? (y/N) " -n 1 -r
            echo # move to a new line

            if [[ $REPLY =~ ^[Yy]$ ]]; then
                open_repo
            fi
        fi

    fi
}

case $1 in
"--open")
    open_repo
    ;;

"--add")
    clone_repo "$2"
    ;;

"--remove")
    remove_repo
    ;;

"--status")
    get_status
    ;;

*)
    print_negative "Invalid option."
    print_info "Usage: repo [--open|--add|--remove|--status]"
    ;;
esac
